// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.25.0
// source: bet.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createBet = `-- name: CreateBet :one
INSERT INTO
    bets (gambler_id, bet_type, bet_price, bet_choice)
VALUES
    ($1, $2, $3, $4) RETURNING id, gambler_id, bet_type, bet_price, bet_choice, deleted_at
`

type CreateBetParams struct {
	GamblerID int32   `db:"gambler_id" json:"gambler_id"`
	BetType   string  `db:"bet_type" json:"bet_type"`
	BetPrice  float64 `db:"bet_price" json:"bet_price"`
	BetChoice string  `db:"bet_choice" json:"bet_choice"`
}

func (q *Queries) CreateBet(ctx context.Context, arg CreateBetParams) (Bet, error) {
	row := q.db.QueryRow(ctx, createBet,
		arg.GamblerID,
		arg.BetType,
		arg.BetPrice,
		arg.BetChoice,
	)
	var i Bet
	err := row.Scan(
		&i.ID,
		&i.GamblerID,
		&i.BetType,
		&i.BetPrice,
		&i.BetChoice,
		&i.DeletedAt,
	)
	return i, err
}

const deleteBet = `-- name: DeleteBet :one
UPDATE 
    bets
SET 
    deleted_at = $1
WHERE 
    id = $2 RETURNING id, gambler_id, bet_type, bet_price, bet_choice, deleted_at
`

type DeleteBetParams struct {
	DeletedAt pgtype.Timestamp `db:"deleted_at" json:"deleted_at"`
	ID        int32            `db:"id" json:"id"`
}

func (q *Queries) DeleteBet(ctx context.Context, arg DeleteBetParams) (Bet, error) {
	row := q.db.QueryRow(ctx, deleteBet, arg.DeletedAt, arg.ID)
	var i Bet
	err := row.Scan(
		&i.ID,
		&i.GamblerID,
		&i.BetType,
		&i.BetPrice,
		&i.BetChoice,
		&i.DeletedAt,
	)
	return i, err
}

const getBet = `-- name: GetBet :one
SELECT
    bets.id, bets.gambler_id, bets.bet_type, bets.bet_price, bets.bet_choice, bets.deleted_at,
    gamblers.id, gamblers.gambler_name, gamblers.document, gamblers.document_type, gamblers.birth_date, gamblers.updated_at, gamblers.deleted_at
FROM
    bets
    JOIN gamblers ON bets.gambler_id = gamblers.id
WHERE
    bets.id = $1
    AND bets.deleted_at IS NOT NULL
`

type GetBetRow struct {
	Bet     Bet     `db:"bet" json:"bet"`
	Gambler Gambler `db:"gambler" json:"gambler"`
}

func (q *Queries) GetBet(ctx context.Context, id int32) (GetBetRow, error) {
	row := q.db.QueryRow(ctx, getBet, id)
	var i GetBetRow
	err := row.Scan(
		&i.Bet.ID,
		&i.Bet.GamblerID,
		&i.Bet.BetType,
		&i.Bet.BetPrice,
		&i.Bet.BetChoice,
		&i.Bet.DeletedAt,
		&i.Gambler.ID,
		&i.Gambler.GamblerName,
		&i.Gambler.Document,
		&i.Gambler.DocumentType,
		&i.Gambler.BirthDate,
		&i.Gambler.UpdatedAt,
		&i.Gambler.DeletedAt,
	)
	return i, err
}

const getBets = `-- name: GetBets :many
SELECT
    bets.id, bets.gambler_id, bets.bet_type, bets.bet_price, bets.bet_choice, bets.deleted_at,
    gamblers.id, gamblers.gambler_name, gamblers.document, gamblers.document_type, gamblers.birth_date, gamblers.updated_at, gamblers.deleted_at
FROM
    bets
    JOIN gamblers ON bets.gambler_id = gamblers.id
WHERE 
    bets.deleted_at IS NOT NULL
`

type GetBetsRow struct {
	Bet     Bet     `db:"bet" json:"bet"`
	Gambler Gambler `db:"gambler" json:"gambler"`
}

func (q *Queries) GetBets(ctx context.Context) ([]GetBetsRow, error) {
	rows, err := q.db.Query(ctx, getBets)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetBetsRow
	for rows.Next() {
		var i GetBetsRow
		if err := rows.Scan(
			&i.Bet.ID,
			&i.Bet.GamblerID,
			&i.Bet.BetType,
			&i.Bet.BetPrice,
			&i.Bet.BetChoice,
			&i.Bet.DeletedAt,
			&i.Gambler.ID,
			&i.Gambler.GamblerName,
			&i.Gambler.Document,
			&i.Gambler.DocumentType,
			&i.Gambler.BirthDate,
			&i.Gambler.UpdatedAt,
			&i.Gambler.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateBet = `-- name: UpdateBet :one
UPDATE 
    bets
SET 
    bet_type = $1,
    bet_price = $2,
    bet_choice = $3
WHERE 
    id = $4 AND bets.deleted_at IS NOT NULL RETURNING id, gambler_id, bet_type, bet_price, bet_choice, deleted_at
`

type UpdateBetParams struct {
	BetType   string  `db:"bet_type" json:"bet_type"`
	BetPrice  float64 `db:"bet_price" json:"bet_price"`
	BetChoice string  `db:"bet_choice" json:"bet_choice"`
	ID        int32   `db:"id" json:"id"`
}

func (q *Queries) UpdateBet(ctx context.Context, arg UpdateBetParams) (Bet, error) {
	row := q.db.QueryRow(ctx, updateBet,
		arg.BetType,
		arg.BetPrice,
		arg.BetChoice,
		arg.ID,
	)
	var i Bet
	err := row.Scan(
		&i.ID,
		&i.GamblerID,
		&i.BetType,
		&i.BetPrice,
		&i.BetChoice,
		&i.DeletedAt,
	)
	return i, err
}
